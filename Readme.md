# COL226 Assignment-4

> **Name : ** Hemank Bajaj
>
> **Entry Number : ** 2020CS10349
>
> **Contact Number : ** cs1200349@cse.iitd.ac.in
>
> **Email : ** +91 6284776699

## VMC Machine for WHILE Language

In this assignment, we make a VMC machine for evaluating programs in the **WHILE** language. The VMC machine is a state machine with state <V , M, C>. V denotes the evaluation stack which is used for computing postfix expressions. C is the code stack in which we store the entire programs as commands in postfix order. M is the memory array.  We also implement our own generic stack which is used for making V and C. 

## How to Use the VMC Machine

In this section we discuss about how to use the VMC machine. To run the code, first compile the project using the command :

```
make run
```

After building the project we are prompted to enter the name of the file that we wish to run.  Enter the name of the program. 

We can run the following commands to evaluate and study the programs :

**Execute the WHILE program : ** To execute a while program use the following command in the opened sml interface. The command executes the WHILE program with the given name :

```
Vmc.execute("<WHILE program name>") ;
```

**Genrerate AST :** To generate the AST with which we evaluate the program use the following command : 

```
generateAST ("< WHILE program name >") ;
```

**Get Postfix Expression : ** To get the postfix expression, use the following :

```
Vmc.postfix("< WHILE program name >") ;
```

**Get The String of <V, M, C> configuration **: To use the toString function which gives the current <V, M, C> configuration, use the following command. Make sure that you enter the datatypes correctly (V : string Stack, M : int array, C : CmdStackElement Stack) : 

```
Vmc.toString(V, M, C);
```

**Get Current Memory Configuration : ** Since, we use memory array as a global array, just type  the following in the SML interface:

```
M ;  (*M is the globally declared memory array*)
```

To run some other program, exit the SML interface and re-run the program. 

## File Structure

Our VMC Machine's Code has the following files :

- **while_ast.sml ** : We define all the data types for our AST in this file. We discuss this file in more detail in further sections. 
- **while_comp.sml** : This file contains the glue code for YACC and LEX files. It defines the actions to be performed for parsing a ***WHILE*** program. This file also has all the functions used to create postfix ecpressions and evaluate the expressions. This file also initializes the memory array. We also define the VMC structure in this file. 
- **while.lex** :  This file is our lexer. It generates tokens and sends it to the YACC parser.
- **while.yacc** : This file parses our program using the YACC tool. 
- **while_loader.sml** : This file loads various sml files together and also sets the Printing Depth to print out the ASTs  nicely. 
- **makefile** : This file is used to build our project and clean the files generated by ML-YACC and ML-LEX. 
- **Stack.sml** : This file contains the Structure of our self-defined generic Stack.

## How does our VMC Machine work ?

To evaluate programs, we use the AST derived in the previous assignment. We take out the declaration sewuence from it and the Command Sequence from it. We then use the Declaration Sequence to prepare the symbol table and assign memory locations to various declared variables. After this we use the declaration sequence to create a post-fix expression of various commands of our code. Our VMC machine is a state machine which on encountering a particular configuration <V, M, C> converts to <V', M', C' > configuration based on different rules defined in our VMC structure. Using these rules we evaluate the while programs. 

## Important Design and Implementation Details

**Creating The Memory : ** To create the memory we create a list of elements initialized with -1 and then convert this list to an int array. Whenever, I need to reserve space whenever it is declared I give then smallest index to that variable which is not initialized. On every decaration, I initialize the variable with 0. Our memory, is a global array. 

**Symbol Table :** To create the Symbol Table, we first derive the declaration sequence. For every variable that is declared, we also put that variable into the symbol table as VAR( id , type , index in M).  We can update, read variables by finding them in the symbol table and then interacting with the memory array. 

**PostFix Expression Evaluation : ** We derive the Cmmand Sequence from the AST to convert it into a postfix expression. We convert different constructors in the AST into a postfix expression recursively. This is similar to deriving the post-order traversal of a Tree. To evaluate ITE and WH expressions, I store the command sequences completely on the evaluator and first evaluate the bool exrpressions and then push or pop the elements on the Code Stack based on the evaluate bool expression. 

**VMC Machine : ** Our VMC Machine has four functions. First, which helps us to define the configuration changes in our VMC machine. This function is used repeatedly to evaluate the programs. Second, we also have the execute function which uses the above rules to execute the program. Third, we have a postfix function to evaluate the postfix of a program's command sequence. Last, we have a toString function. In this function, we convert the <V, M, C> configuration provided as an argument to a string which can be printed. 

## Acknowledgements

Before I thank anyone else, I would like to thank my teacher **Prof. S Arun Kumar** for providing this great learning opportunity through this assignment. Also, I would like to thank the following books and online resources which helped me a lot in completig this assignment :

1. SML Family Github (https://smlfamily.github.io/) : This website helped me a lot in learning about various inbuiilt libraries in ML. I have used Arrays in my code and read about their functions from here. 
2.  **ML-Lex and ML-Yacc Book by Roger Price**: I used this book to get knowledge of using ML-LEX and ML-YACC together in projects like ours. I understood how to organize my file structure and code-structure from this book.  [Roger Brice Book Link](http://rogerprice.org/ug/ug.pdf "Roger Brice Book Link")
3. **StackOverFlow** : This website helped me in removing a lot of bugs in my code. I am deeply indebted to the creators of this website.



# THANK YOU !

